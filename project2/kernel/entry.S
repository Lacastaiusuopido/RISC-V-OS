.section .text
.globl _entry
_entry:
    # 设置内核栈
    # 为每个hart（硬件线程）分配独立的栈空间
    la sp, stack0          # 加载栈基地址
    li a0, 1024            # 每个hart的栈大小为1024字节
    csrr a1, mhartid       # 读取当前hart ID
    addi a1, a1, 1         # hart ID + 1
    mul a0, a0, a1         # 计算栈偏移量
    add sp, sp, a0         # 设置最终栈指针

    # 跳转到 kernel_main
    call kernel_main       # 调用C语言的内核主函数

# 中断向量表入口点
# 当发生中断或异常时，硬件会自动跳转到这里
.align 4                   # 地址对齐到4字节边界
.globl trap_vector
trap_vector:

    # 为所有寄存器分配栈空间 (32个寄存器 * 8字节)
    addi sp, sp, -256      # 在栈上分配256字节空间

    # 保存通用寄存器
    # 这些寄存器需要保存，因为中断处理函数可能会修改它们
    sd ra, 0(sp)           # 返回地址
    sd sp, 8(sp)           # 栈指针（保存原始值）
    sd gp, 16(sp)          # 全局指针
    sd tp, 24(sp)          # 线程指针
    sd t0, 32(sp)          # 临时寄存器0
    sd t1, 40(sp)          # 临时寄存器1
    sd t2, 48(sp)          # 临时寄存器2
    sd s0, 56(sp)          # 保存寄存器0/帧指针
    sd s1, 64(sp)          # 保存寄存器1
    sd a0, 72(sp)          # 参数/返回值寄存器0
    sd a1, 80(sp)          # 参数/返回值寄存器1
    sd a2, 88(sp)          # 参数寄存器2
    sd a3, 96(sp)          # 参数寄存器3
    sd a4, 104(sp)         # 参数寄存器4
    sd a5, 112(sp)         # 参数寄存器5
    sd a6, 120(sp)         # 参数寄存器6
    sd a7, 128(sp)         # 参数寄存器7/系统调用号
    sd s2, 136(sp)         # 保存寄存器2
    sd s3, 144(sp)         # 保存寄存器3
    sd s4, 152(sp)         # 保存寄存器4
    sd s5, 160(sp)         # 保存寄存器5
    sd s6, 168(sp)         # 保存寄存器6
    sd s7, 176(sp)         # 保存寄存器7
    sd s8, 184(sp)         # 保存寄存器8
    sd s9, 192(sp)         # 保存寄存器9
    sd s10, 200(sp)        # 保存寄存器10
    sd s11, 208(sp)        # 保存寄存器11
    sd t3, 216(sp)         # 临时寄存器3
    sd t4, 224(sp)         # 临时寄存器4
    sd t5, 232(sp)         # 临时寄存器5
    sd t6, 240(sp)         # 临时寄存器6

    # 读取中断相关CSR（控制状态寄存器）
    csrr a0, scause        # 读取中断/异常原因
    csrr a1, sepc          # 读取中断/异常发生时的程序计数器值
    csrr a2, stval         # 读取中断/异常相关的附加信息
    
    # 传递寄存器数组指针作为第四个参数
    # 这样C语言的中断处理函数可以访问和修改所有保存的寄存器
    addi a3, sp, 0         # 将栈指针作为第四个参数传递
    
    # 调用C语言中断处理函数
    # 这将跳转到trap.c中的trap_handler函数
    call trap_handler

    # 恢复通用寄存器
    # 注意：如果trap_handler修改了某些寄存器值，这些修改会被保留
    ld ra, 0(sp)           # 恢复返回地址
    # 跳过sp的恢复，因为我们正在使用它
    ld gp, 16(sp)          # 恢复全局指针
    ld tp, 24(sp)          # 恢复线程指针
    ld t0, 32(sp)          # 恢复临时寄存器0
    ld t1, 40(sp)          # 恢复临时寄存器1
    ld t2, 48(sp)          # 恢复临时寄存器2
    ld s0, 56(sp)          # 恢复保存寄存器0/帧指针
    ld s1, 64(sp)          # 恢复保存寄存器1
    ld a0, 72(sp)          # 恢复参数/返回值寄存器0
    ld a1, 80(sp)          # 恢复参数/返回值寄存器1
    ld a2, 88(sp)          # 恢复参数寄存器2
    ld a3, 96(sp)          # 恢复参数寄存器3
    ld a4, 104(sp)         # 恢复参数寄存器4
    ld a5, 112(sp)         # 恢复参数寄存器5
    ld a6, 120(sp)         # 恢复参数寄存器6
    ld a7, 128(sp)         # 恢复参数寄存器7/系统调用号
    ld s2, 136(sp)         # 恢复保存寄存器2
    ld s3, 144(sp)         # 恢复保存寄存器3
    ld s4, 152(sp)         # 恢复保存寄存器4
    ld s5, 160(sp)         # 恢复保存寄存器5
    ld s6, 168(sp)         # 恢复保存寄存器6
    ld s7, 176(sp)         # 恢复保存寄存器7
    ld s8, 184(sp)         # 恢复保存寄存器8
    ld s9, 192(sp)         # 恢复保存寄存器9
    ld s10, 200(sp)        # 恢复保存寄存器10
    ld s11, 208(sp)        # 恢复保存寄存器11
    ld t3, 216(sp)         # 恢复临时寄存器3
    ld t4, 224(sp)         # 恢复临时寄存器4
    ld t5, 232(sp)         # 恢复临时寄存器5
    ld t6, 240(sp)         # 恢复临时寄存器6

    # 恢复栈指针
    addi sp, sp, 256       # 释放之前分配的栈空间

    # 从中断返回
    # sret指令会从sepc寄存器中加载PC值，并恢复中断前的特权级
    sret                   # 返回到中断前的位置继续执行

# 数据段
.section .data
.align 12                  # 4KB对齐（页面对齐）
stack0:
    .space 4096            # 分配4KB的内核栈空间